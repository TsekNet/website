{"version":3,"file":"index.min.js","sources":["../../src/SearchableMap/TreeIterator.js","../../src/SearchableMap/fuzzySearch.js","../../src/SearchableMap/SearchableMap.js","../../src/MiniSearch.js"],"sourcesContent":["/**\n* @private\n*/\nclass TreeIterator {\n  constructor (set, type) {\n    const node = set._tree\n    const keys = Object.keys(node)\n    this.set = set\n    this.type = type\n    this.path = keys.length > 0 ? [{ node, keys }] : []\n  }\n\n  next () {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }\n\n  dive () {\n    if (this.path.length === 0) { return { done: true } }\n    const { node, keys } = last(this.path)\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n    this.path.push({ node: node[last(keys)], keys: Object.keys(node[last(keys)]) })\n    return this.dive()\n  }\n\n  backtrack () {\n    if (this.path.length === 0) { return }\n    last(this.path).keys.pop()\n    if (last(this.path).keys.length > 0) { return }\n    this.path.pop()\n    this.backtrack()\n  }\n\n  key () {\n    return this.set._prefix + this.path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }\n\n  value () {\n    return last(this.path).node[LEAF]\n  }\n\n  result () {\n    if (this.type === VALUES) { return this.value() }\n    if (this.type === KEYS) { return this.key() }\n    return [this.key(), this.value()]\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}\n\n/** @ignore */\nconst ENTRIES = 'ENTRIES'\n\n/** @ignore */\nconst KEYS = 'KEYS'\n\n/** @ignore */\nconst VALUES = 'VALUES'\n\n/** @ignore */\nconst LEAF = ''\n\nconst last = function (array) {\n  return array[array.length - 1]\n}\n\nexport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF }\n","import { LEAF } from './TreeIterator.js'\n\n/**\n* @ignore\n*/\nexport const fuzzySearch = function (node, query, maxDistance) {\n  const stack = [{ distance: 0, i: 0, key: '', node }]\n  const results = {}\n  const innerStack = []\n\n  while (stack.length > 0) {\n    const { node, distance, key, i, edit } = stack.pop()\n    Object.keys(node).forEach((k) => {\n      if (k === LEAF) {\n        const totDistance = distance + (query.length - i)\n        const [, d] = results[key] || [null, Infinity]\n        if (totDistance <= maxDistance && totDistance < d) {\n          results[key] = [node[k], totDistance]\n        }\n      } else {\n        withinDistance(query, k, maxDistance - distance, i, edit, innerStack).forEach(({ distance: d, i, edit }) => {\n          stack.push({ node: node[k], distance: distance + d, key: key + k, i, edit })\n        })\n      }\n    })\n  }\n  return results\n}\n\n/**\n* @ignore\n*/\nexport const withinDistance = function (a, b, maxDistance, i, edit, stack) {\n  stack.push({ distance: 0, ia: i, ib: 0, edit })\n  const results = []\n\n  while (stack.length > 0) {\n    const { distance, ia, ib, edit } = stack.pop()\n\n    if (ib === b.length) {\n      results.push({ distance, i: ia, edit })\n      continue\n    }\n\n    if (a[ia] === b[ib]) {\n      stack.push({ distance, ia: ia + 1, ib: ib + 1, edit: NONE })\n    } else {\n      if (distance >= maxDistance) { continue }\n\n      if (edit !== ADD) {\n        stack.push({ distance: distance + 1, ia, ib: ib + 1, edit: DELETE })\n      }\n\n      if (ia < a.length) {\n        if (edit !== DELETE) {\n          stack.push({ distance: distance + 1, ia: ia + 1, ib, edit: ADD })\n        }\n\n        if (edit !== DELETE && edit !== ADD) {\n          stack.push({ distance: distance + 1, ia: ia + 1, ib: ib + 1, edit: CHANGE })\n        }\n      }\n    }\n  }\n\n  return results\n}\n\nconst NONE = 0\nconst CHANGE = 1\nconst ADD = 2\nconst DELETE = 3\n\nexport default fuzzySearch\n","import { TreeIterator, ENTRIES, KEYS, VALUES, LEAF } from './TreeIterator.js'\nimport fuzzySearch from './fuzzySearch.js'\n\n/**\n* A class implementing the same interface as a standard JavaScript `Map` with\n* string keys, but adding support for efficiently searching entries with prefix\n* or fuzzy search. This is the class internally used by `MiniSearch` as the\n* inverted index data structure. The implementation is a radix tree (compressed\n* prefix tree).\n*\n* @implements {Map}\n*/\nclass SearchableMap {\n  constructor (tree = {}, prefix = '') {\n    /** @private */\n    this._tree = tree\n    /** @private */\n    this._prefix = prefix\n  }\n\n  /**\n  * Creates and returns a mutable view of this `SearchableMap`, containing only\n  * entries that share the given prefix.\n  *\n  * @example\n  * let map = new SearchableMap()\n  * map.set(\"unicorn\", 1)\n  * map.set(\"universe\", 2)\n  * map.set(\"university\", 3)\n  * map.set(\"unique\", 4)\n  * map.set(\"hello\", 5)\n  *\n  * let uni = map.atPrefix(\"uni\")\n  * uni.get(\"unique\") // => 4\n  * uni.get(\"unicorn\") // => 1\n  * uni.get(\"hello\") // => undefined\n  *\n  * let univer = map.atPrefix(\"univer\")\n  * univer.get(\"unique\") // => undefined\n  * univer.get(\"universe\") // => 2\n  * univer.get(\"university\") // => 3\n  *\n  * @param {string} prefix - The prefix\n  * @return {SearchableMap} A `SearchableMap` representing a mutable view of the original Map at the given prefix\n  */\n  atPrefix (prefix) {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n      const nodeKey = Object.keys(parentNode).find(k => k !== LEAF && k.startsWith(key))\n      if (nodeKey !== undefined) {\n        return new SearchableMap({ [nodeKey.slice(key.length)]: parentNode[nodeKey] }, prefix)\n      }\n    }\n    return new SearchableMap(node || {}, prefix)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n  * @return {undefined}\n  */\n  clear () {\n    delete this._size\n    this._tree = {}\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n  * @param {string} key\n  * @return {undefined}\n  */\n  delete (key) {\n    delete this._size\n    return remove(this._tree, key)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n  * @return {Iterator}\n  */\n  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }\n\n  /**\n   * @callback SearchableMap~forEachFn\n   * @param {string} key - Key\n   * @param {any} value - Value associated to key\n   * @return any\n   */\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n  * @param {SearchableMap~forEachFn} fn\n  * @return {undefined}\n  */\n  forEach (fn) {\n    for (const [key, value] of this) {\n      fn(key, value, this)\n    }\n  }\n\n  /**\n  * Returns a key-value object of all the entries that have a key within the\n  * given edit distance from the search key. The keys of the returned object are\n  * the matching keys, while the values are two-elements arrays where the first\n  * element is the value associated to the key, and the second is the edit\n  * distance of the key to the search key.\n  *\n  * @example\n  * let map = new SearchableMap()\n  * map.set('hello', 'world')\n  * map.set('hell', 'yeah')\n  * map.set('ciao', 'mondo')\n  *\n  * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n  * map.fuzzyGet('hallo', 2)\n  * // => { \"hello\": [\"world\", 1], \"hell\": [\"yeah\", 2] }\n  *\n  * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n  * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n  * // (change \"e\" to \"a\", delete \"o\")\n  *\n  * @param {string} key - The search key\n  * @param {number} maxEditDistance - The maximum edit distance\n  * @return {Object<string, Array>} A key-value object of the matching keys to their value and edit distance\n  */\n  fuzzyGet (key, maxEditDistance) {\n    return fuzzySearch(this._tree, key, maxEditDistance)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n  * @param {string} key\n  * @return {any}\n  */\n  get (key) {\n    const node = lookup(this._tree, key)\n    return node !== undefined ? node[LEAF] : undefined\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n  * @param {string} key\n  * @return {boolean}\n  */\n  has (key) {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.hasOwnProperty(LEAF)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n  * @return {Iterator}\n  */\n  keys () {\n    return new TreeIterator(this, KEYS)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n  * @param {string} key\n  * @param {any} value\n  * @return {SearchableMap} The `SearchableMap` itself, to allow chaining\n  */\n  set (key, value) {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    delete this._size\n    const node = createPath(this._tree, key)\n    node[LEAF] = value\n    return this\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n  * @type {number}\n  */\n  get size () {\n    if (this._size) { return this._size }\n    /** @ignore */\n    this._size = 0\n    this.forEach(() => { this._size += 1 })\n    return this._size\n  }\n\n  /**\n   * @callback SearchableMap~updateFn\n   * @param {any} currentValue - The current value\n   * @return any - the updated value\n   */\n\n  /**\n  * Updates the value at the given key using the provided function. The function\n  * is called with the current value at the key, and its return value is used as\n  * the new value to be set.\n  *\n  * @example\n  * // Increment the current value by one\n  * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n  *\n  * @param {string} key - The key\n  * @param {SearchableMap~updateFn} fn - The function used to compute the new value from the current one\n  * @return {SearchableMap} The `SearchableMap` itself, to allow chaining\n  */\n  update (key, fn) {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    delete this._size\n    const node = createPath(this._tree, key)\n    node[LEAF] = fn(node[LEAF])\n    return this\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n  * @return {Iterator}\n  */\n  values () {\n    return new TreeIterator(this, VALUES)\n  }\n\n  /**\n  * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n  * @return {Iterator}\n  */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n}\n\n/**\n* Creates a `SearchableMap` from an `Iterable` of entries\n*\n* @param {Iterable|Array} entries - Entries to be inserted in the `SearchableMap`\n* @return {SearchableMap} A new `SearchableMap` with the given entries\n**/\nSearchableMap.from = function (entries) {\n  const tree = new SearchableMap()\n  for (const [key, value] of entries) {\n    tree.set(key, value)\n  }\n  return tree\n}\n\n/**\n* Creates a `SearchableMap` from the iterable properties of a JavaScript object\n*\n* @param {Object} object - Object of entries for the `SearchableMap`\n* @return {SearchableMap} A new `SearchableMap` with the given entries\n**/\nSearchableMap.fromObject = function (object) {\n  return SearchableMap.from(Object.entries(object))\n}\n\nconst trackDown = function (tree, key, path = []) {\n  if (key.length === 0) { return [tree, path] }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) { return trackDown(undefined, '', [...path, [tree, key]]) }\n  return trackDown(tree[nodeKey], key.slice(nodeKey.length), [...path, [tree, nodeKey]])\n}\n\nconst lookup = function (tree, key) {\n  if (key.length === 0) { return tree }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) { return undefined }\n  return lookup(tree[nodeKey], key.slice(nodeKey.length))\n}\n\nconst createPath = function (tree, key) {\n  if (key.length === 0) { return tree }\n  const nodeKey = Object.keys(tree).find(k => k !== LEAF && key.startsWith(k))\n  if (nodeKey === undefined) {\n    const toSplit = Object.keys(tree).find(k => k !== LEAF && k.startsWith(key[0]))\n    if (toSplit === undefined) {\n      tree[key] = {}\n    } else {\n      const prefix = commonPrefix(key, toSplit)\n      tree[prefix] = { [toSplit.slice(prefix.length)]: tree[toSplit] }\n      delete tree[toSplit]\n      return createPath(tree[prefix], key.slice(prefix.length))\n    }\n    return tree[key]\n  }\n  return createPath(tree[nodeKey], key.slice(nodeKey.length))\n}\n\nconst commonPrefix = function (a, b, i = 0, length = Math.min(a.length, b.length), prefix = '') {\n  if (i >= length) { return prefix }\n  if (a[i] !== b[i]) { return prefix }\n  return commonPrefix(a, b, i + 1, length, prefix + a[i])\n}\n\nconst remove = function (tree, key) {\n  const [node, path] = trackDown(tree, key)\n  if (node === undefined) { return }\n  delete node[LEAF]\n  const keys = Object.keys(node)\n  if (keys.length === 0) { cleanup(path) }\n  if (keys.length === 1) { merge(path, keys[0], node[keys[0]]) }\n}\n\nconst cleanup = function (path) {\n  if (path.length === 0) { return }\n  const [node, key] = last(path)\n  delete node[key]\n  if (Object.keys(node).length === 0) {\n    cleanup(path.slice(0, -1))\n  }\n}\n\nconst merge = function (path, key, value) {\n  if (path.length === 0) { return }\n  const [node, nodeKey] = last(path)\n  node[nodeKey + key] = value\n  delete node[nodeKey]\n}\n\nconst last = function (array) {\n  return array[array.length - 1]\n}\n\nexport default SearchableMap\nexport { SearchableMap }\n","import SearchableMap from './SearchableMap/SearchableMap.js'\n\nconst OR = 'or'\nconst AND = 'and'\n\n/**\n* MiniSearch is the main entrypoint class, and represents a full-text search\n* engine.\n*\n* @example\n* const documents = [\n*   {\n*     id: 1,\n*     title: 'Moby Dick',\n*     text: 'Call me Ishmael. Some years ago...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 2,\n*     title: 'Zen and the Art of Motorcycle Maintenance',\n*     text: 'I can see by my watch...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 3,\n*     title: 'Neuromancer',\n*     text: 'The sky above the port was...',\n*     category: 'fiction'\n*   },\n*   {\n*     id: 4,\n*     title: 'Zen and the Art of Archery',\n*     text: 'At first sight it must seem...',\n*     category: 'non-fiction'\n*   },\n*   // ...and more\n* ]\n*\n* // Create a search engine that indexes the 'title' and 'text' fields for\n* // full-text search. Search results will include 'title' and 'category' (plus the\n* // id field, that is always stored and returned)\n* const miniSearch = MiniSearch.new({\n*   fields: ['title', 'text'],\n*   storeFields: ['title', 'category']\n* })\n*\n* // Add documents to the index\n* miniSearch.addAll(documents)\n*\n* // Search for documents:\n* let results = miniSearch.search('zen art motorcycle')\n* // => [\n*   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n*   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n* ]\n* */\nclass MiniSearch {\n  /**\n   * @callback MiniSearch~extractField\n   * @param {Object} document - A document object\n   * @param {string} fieldName - Name of the field to extract\n   * @return string - Value of the field\n   */\n\n  /**\n   * @callback MiniSearch~tokenize\n   * @param {string} text - Text to tokenize\n   * @param {?string} fieldName - Name of the field to tokenize\n   * @return string[] - Tokenized terms\n   */\n\n  /**\n   * @callback MiniSearch~processTerm\n   * @param {string} text - The text to tokenize\n   * @param {?string} fieldName - The name of the field to tokenize\n   * @return string|null|undefined|false - Processed term, or a falsy value to discard the term\n   */\n\n  /**\n  * @param {Object} options - Configuration options\n  * @param {Array<string>} options.fields - Fields to be indexed. Required.\n  * @param {string} [options.idField='id'] - ID field, uniquely identifying a document\n  * @param {Array<string>} [options.storeFields] - Fields to store, so that search results would include them. By default none, so resuts would only contain the id field.\n  * @param {MiniSearch~extractField} [options.extractField] - Function used to get the value of a field in a document\n  * @param {MiniSearch~tokenize} [options.tokenize] - Function used to split a field into individual terms\n  * @param {MiniSearch~processTerm} [options.processTerm] - Function used to process a term before indexing it or searching\n  * @param {Object} [options.searchOptions] - Default search options (see the `search` method for details)\n  *\n  * @example\n  * // Create a search engine that indexes the 'title' and 'text' fields of your\n  * // documents:\n  * const miniSearch = MiniSearch.new({ fields: ['title', 'text'] })\n  *\n  * @example\n  * // Your documents are assumed to include a unique 'id' field, but if you want\n  * // to use a different field for document identification, you can set the\n  * // 'idField' option:\n  * const miniSearch = MiniSearch.new({ idField: 'key', fields: ['title', 'text'] })\n  *\n  * @example\n  * // The full set of options (here with their default value) is:\n  * const miniSearch = MiniSearch.new({\n  *   // idField: field that uniquely identifies a document\n  *   idField: 'id',\n  *\n  *   // extractField: function used to get the value of a field in a document.\n  *   // By default, it assumes the document is a flat object with field names as\n  *   // property keys and field values as string property values, but custom logic\n  *   // can be implemented by setting this option to a custom extractor function.\n  *   extractField: (document, fieldName) => document[fieldName],\n  *\n  *   // tokenize: function used to split fields into individual terms. By\n  *   // default, it is also used to tokenize search queries, unless a specific\n  *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n  *   // the field name is passed as the second argument.\n  *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n  *\n  *   // processTerm: function used to process each tokenized term before\n  *   // indexing. It can be used for stemming and normalization. Return a falsy\n  *   // value in order to discard a term. By default, it is also used to process\n  *   // search queries, unless a specific `processTerm` option is supplied as a\n  *   // search option. When processing a term from a indexed field, the field\n  *   // name is passed as the second argument.\n  *   processTerm: (term, _fieldName) => term.toLowerCase(),\n  *\n  *   // searchOptions: default search options, see the `search` method for\n  *   // details\n  *   searchOptions: undefined,\n  *\n  *   // fields: document fields to be indexed. Mandatory, but not set by default\n  *   fields: undefined\n  *\n  *   // storeFields: document fields to be stored and returned as part of the\n  *   // search results.\n  *   storeFields: []\n  * })\n  */\n  constructor (options = {}) {\n    /** @private */\n    this._options = { ...defaultOptions, ...options }\n\n    this._options.searchOptions = { ...defaultSearchOptions, ...(this._options.searchOptions || {}) }\n    const { fields } = this._options\n\n    if (fields == null) {\n      throw new Error('MiniSearch: option \"fields\" must be provided')\n    }\n\n    /** @private */\n    this._index = new SearchableMap()\n\n    /** @private */\n    this._documentCount = 0\n\n    /** @private */\n    this._documentIds = {}\n\n    /** @private */\n    this._fieldIds = {}\n\n    /** @private */\n    this._fieldLength = {}\n\n    /** @private */\n    this._averageFieldLength = {}\n\n    /** @private */\n    this._nextId = 0\n\n    /** @private */\n    this._storedFields = {}\n\n    addFields(this, fields)\n  }\n\n  /**\n  * Adds a document to the index\n  *\n  * @param {Object} document - the document to be indexed\n  */\n  add (document) {\n    const { extractField, tokenize, processTerm, fields, idField } = this._options\n    if (document[idField] == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n    const shortDocumentId = addDocumentId(this, document[idField])\n    saveStoredFields(this, shortDocumentId, document)\n\n    fields.forEach(field => {\n      const tokens = tokenize(extractField(document, field) || '', field)\n      addFieldLength(this, shortDocumentId, this._fieldIds[field], this.documentCount - 1, tokens.length)\n      tokens.forEach(term => {\n        const processedTerm = processTerm(term, field)\n        if (isTruthy(processedTerm)) {\n          addTerm(this, this._fieldIds[field], shortDocumentId, processedTerm)\n        }\n      })\n    })\n  }\n\n  /**\n  * Adds all the given documents to the index\n  *\n  * @param {Object[]} documents - an array of documents to be indexed\n  */\n  addAll (documents) {\n    documents.forEach(document => this.add(document))\n  }\n\n  /**\n  * Adds all the given documents to the index asynchronously.\n  *\n  * Returns a promise that resolves to undefined when the indexing is done. This\n  * method is useful when index many documents, to avoid blocking the main\n  * thread. The indexing is performed asynchronously and in chunks.\n  *\n  * @param {Object[]} documents - an array of documents to be indexed\n  * @param {Object} [options] - Configuration options\n  * @param {number} [options.chunkSize] - Size of the document chunks indexed, 10 by default\n  * @return {Promise} A promise resolving to `null` when the indexing is done\n  */\n  addAllAsync (documents, options = {}) {\n    const { chunkSize = 10 } = options\n    const acc = { chunk: [], promise: Promise.resolve(null) }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return { chunk: [], promise: promise.then(() => this.addAll(chunk)) }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }\n\n  /**\n  * Removes the given document from the index.\n  *\n  * The document to delete must NOT have changed between indexing and deletion,\n  * otherwise the index will be corrupted. Therefore, when reindexing a document\n  * after a change, the correct order of operations is:\n  *\n  *   1. remove old version\n  *   2. apply changes\n  *   3. index new version\n  *\n  * @param {Object} document - the document to be removed\n  */\n  remove (document) {\n    const { tokenize, processTerm, extractField, fields, idField } = this._options\n\n    if (document[idField] == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    const [shortDocumentId] = Object.entries(this._documentIds)\n      .find(([_, longId]) => document[idField] === longId) || []\n\n    if (shortDocumentId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${document[idField]}: it is not in the index`)\n    }\n\n    fields.filter(field => document[field] != null).forEach(field => {\n      const tokens = tokenize(extractField(document, field) || '', field)\n\n      tokens.forEach(term => {\n        const processedTerm = processTerm(term, field)\n        if (isTruthy(processedTerm)) {\n          removeTerm(this, this._fieldIds[field], shortDocumentId, processedTerm)\n        }\n      })\n    })\n\n    delete this._storedFields[shortDocumentId]\n    delete this._documentIds[shortDocumentId]\n    this._documentCount -= 1\n  }\n\n  /**\n  * Removes all the given documents from the index. If called with no arguments,\n  * it removes _all_ documents from the index.\n  *\n  * @param {Array<Object>} [documents] - the documents to be removed\n  */\n  removeAll (documents) {\n    if (arguments.length === 0) {\n      this._index = new SearchableMap()\n      this._documentCount = 0\n      this._documentIds = {}\n      this._fieldLength = {}\n      this._averageFieldLength = {}\n      this._storedFields = {}\n      this._nextId = 0\n    } else {\n      documents.forEach(document => this.remove(document))\n    }\n  }\n\n  /**\n   * @callback MiniSearch~prefixFn\n   * @param {string} term - Search term\n   * @param {number} i - Index of the term in the query terms array\n   * @param {string[]} terms - Array of all query terms\n   * @return boolean - `true` to perform prefix search, `false` to not perform it\n   */\n\n  /**\n   * @callback MiniSearch~fuzzyFn\n   * @param {string} term - Search term\n   * @param {number} i - Index of the search term in the tokenized search query\n   * @param {string[]} terms - Array of all query terms\n   * @return number|false - Maximum edit distance, or `false` to not perform fuzzy search\n   */\n\n  /**\n   * @callback MiniSearch~filter\n   * @param {Object} result - A search result\n   * @return boolean - `true` to keep the result, `false` to filter it out\n   */\n\n  /**\n  * Search for documents matching the given search query.\n  *\n  * The result is a list of scored document IDs matching the query, sorted by\n  * descending score, and each including data about which terms were matched and\n  * in which fields.\n  *\n  * @param {string} queryString - Query string to search for\n  * @param {Object} [options] - Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n  * @param {Array<string>} [options.fields] - Fields to search in. If omitted, all fields are searched\n  * @param {Object<string, number>} [options.boost] - Key-value object of boosting values for fields\n  * @param {boolean|MiniSearch~prefixFn} [options.prefix=false] - Whether to perform prefix search. Value can be a boolean, or a function computing the boolean from each tokenized and processed query term. If a function is given, it is called with the following arguments: `term: string` - the query term; `i: number` - the term index in the query terms; `terms: Array<string>` - the array of query terms.\n  * @param {number|false|MiniSearch~fuzzyFn} [options.fuzzy=false] - If set to a number greater than or equal 1, it performs fuzzy search within a maximum edit distance equal to that value. If set to a number less than 1, it performs fuzzy search with a maximum edit distance equal to the term length times the value, rouded at the nearest integer. If set to a function, it calls the function for each tokenized and processed query term and expects a numeric value indicating the maximum edit distance, or a falsy falue if fuzzy search should not be performed. If a function is given, it is called with the following arguments: `term: string` - the query term; `i: number` - the term index in the query terms; `terms: Array<string>` - the array of query terms.\n  * @param {string} [options.combineWith='OR'] - How to combine term queries (it can be 'OR' or 'AND')\n  * @param {MiniSearch~tokenize} [options.tokenize] - Function used to tokenize the search query. It defaults to the same tokenizer used for indexing.\n  * @param {MiniSearch~processTerm} [options.processTerm] - Function used to process each search term. Return a falsy value to discard a term. Defaults to the same function used to process terms upon indexing.\n  * @param {MiniSearch~filter} [options.filter] - Function used to filter search results, for example on the basis of stored fields\n  * @return {Array<{ id: any, score: number, match: Object }>} A sorted array of scored document IDs matching the search\n  *\n  * @example\n  * // Search for \"zen art motorcycle\" with default options: terms have to match\n  * // exactly, and individual terms are joined with OR\n  * miniSearch.search('zen art motorcycle')\n  * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n  *\n  * @example\n  * // Search only in the 'title' field\n  * miniSearch.search('zen', { fields: ['title'] })\n  *\n  * @example\n  * // Boost a field\n  * miniSearch.search('zen', { boost: { title: 2 } })\n  *\n  * @example\n  * // Search for \"moto\" with prefix search (it will match documents\n  * // containing terms that start with \"moto\" or \"neuro\")\n  * miniSearch.search('moto neuro', { prefix: true })\n  *\n  * @example\n  * // Search for \"ismael\" with fuzzy search (it will match documents containing\n  * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n  * // (rounded to nearest integer)\n  * miniSearch.search('ismael', { fuzzy: 0.2 })\n  *\n  * @example\n  * // Mix of exact match, prefix search, and fuzzy search\n  * miniSearch.search('ismael mob', {\n  *  prefix: true,\n  *  fuzzy: 0.2\n  * })\n  *\n  * @example\n  * // Perform fuzzy and prefix search depending on the search term. Here\n  * // performing prefix and fuzzy search only on terms longer than 3 characters\n  * miniSearch.search('ismael mob', {\n  *  prefix: term => term.length > 3\n  *  fuzzy: term => term.length > 3 ? 0.2 : null\n  * })\n  *\n  * @example\n  * // Combine search terms with AND (to match only documents that contain both\n  * // \"motorcycle\" and \"art\")\n  * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n  *\n  * @example\n  * // Filter only results in the 'fiction' category (assuming that 'category'\n  * // is a stored field)\n  * miniSearch.search('motorcycle art', {\n  *   filter: (result) => result.category === 'fiction'\n  * })\n  */\n  search (queryString, options = {}) {\n    const { tokenize, processTerm, searchOptions } = this._options\n    options = { tokenize, processTerm, ...searchOptions, ...options }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const queries = searchTokenize(queryString)\n      .map((term) => searchProcessTerm(term))\n      .filter(isTruthy)\n      .map(termToQuery(options))\n    const results = queries.map(query => this.executeQuery(query, options))\n    const combinedResults = this.combineResults(results, options.combineWith)\n\n    return Object.entries(combinedResults)\n      .reduce((results, [docId, { score, match, terms }]) => {\n        const result = {\n          id: this._documentIds[docId],\n          terms: uniq(terms),\n          score,\n          match\n        }\n        Object.assign(result, this._storedFields[docId])\n        if (options.filter == null || options.filter(result)) {\n          results.push(result)\n        }\n        return results\n      }, [])\n      .sort(({ score: a }, { score: b }) => a < b ? 1 : -1)\n  }\n\n  /**\n  * Provide suggestions for the given search query\n  *\n  * The result is a list of suggested modified search queries, derived from the\n  * given search query, each with a relevance score, sorted by descending score.\n  *\n  * @param {string} queryString - Query string to be expanded into suggestions\n  * @param {Object} [options] - Search options. The supported options and default values are the same as for the `search` method, except that by default prefix search is performed on the last term in the query.\n  * @return {Array<{ suggestion: string, score: number }>} A sorted array of suggestions sorted by relevance score.\n  *\n  * @example\n  * // Get suggestions for 'neuro':\n  * miniSearch.autoSuggest('neuro')\n  * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n  *\n  * @example\n  * // Get suggestions for 'zen ar':\n  * miniSearch.autoSuggest('zen ar')\n  * // => [\n  * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n  * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n  * // ]\n  *\n  * @example\n  * // Correct spelling mistakes using fuzzy search:\n  * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n  * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n  *\n  * @example\n  * // Get suggestions for 'zen ar', but only within the 'fiction' category\n  * // (assuming that 'category' is a stored field):\n  * miniSearch.autoSuggest('zen ar', {\n  *   filter: (result) => result.category === 'fiction'\n  * })\n  * // => [\n  * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n  * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n  * // ]\n  */\n  autoSuggest (queryString, options = {}) {\n    options = { ...defaultAutoSuggestOptions, ...options }\n    const suggestions = this.search(queryString, options).reduce((suggestions, { score, terms }) => {\n      const phrase = terms.join(' ')\n      if (suggestions[phrase] == null) {\n        suggestions[phrase] = { score, terms, count: 1 }\n      } else {\n        suggestions[phrase].score += score\n        suggestions[phrase].count += 1\n      }\n      return suggestions\n    }, {})\n    return Object.entries(suggestions)\n      .map(([suggestion, { score, terms, count }]) => ({ suggestion, terms, score: score / count }))\n      .sort(({ score: a }, { score: b }) => a < b ? 1 : -1)\n  }\n\n  /**\n  * Number of documents in the index\n  *\n  * @type {number}\n  */\n  get documentCount () {\n    return this._documentCount\n  }\n\n  /**\n  * Deserializes a JSON index (serialized with `miniSearch.toJSON()`) and\n  * instantiates a MiniSearch instance. It should be given the same options\n  * originally used when serializing the index.\n  *\n  * **Warning:** JSON (de)serialization of the index is currently tightly\n  * coupled to the index implementation. For this reason, the current\n  * implementation is to be considered a _beta_ feature, subject to breaking\n  * changes changes in future releases. If a breaking change is introduced,\n  * though, it will be properly reported in the changelog.\n  *\n  * @param {string} json - JSON-serialized index\n  * @param {Object} options - configuration options, same as the constructor\n  * @return {MiniSearch} an instance of MiniSearch\n  */\n  static loadJSON (json, options) {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return MiniSearch.loadJS(JSON.parse(json), options)\n  }\n\n  /**\n  * Get the default value of an option. It will throw an error if no option with\n  * the given name exists.\n  *\n  * @param {string} optionName - name of the option\n  * @return {any} the default value of the given option\n  *\n  * @example\n  * // Get default tokenizer\n  * MiniSearch.getDefault('tokenize')\n  *\n  * @example\n  * // Get default term processor\n  * MiniSearch.getDefault('processTerm')\n  *\n  * @example\n  * // Unknown options will throw an error\n  * MiniSearch.getDefault('notExisting')\n  * // => throws 'MiniSearch: unknown option \"notExisting\"'\n  */\n  static getDefault (optionName) {\n    if (defaultOptions.hasOwnProperty(optionName)) {\n      return defaultOptions[optionName]\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }\n\n  /**\n  * @private\n  */\n  static loadJS (js, options = {}) {\n    const {\n      index,\n      documentCount,\n      nextId,\n      documentIds,\n      fieldIds,\n      fieldLength,\n      averageFieldLength,\n      storedFields\n    } = js\n    const miniSearch = new MiniSearch(options)\n    miniSearch._index = new SearchableMap(index._tree, index._prefix)\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._documentIds = documentIds\n    miniSearch._fieldIds = fieldIds\n    miniSearch._fieldLength = fieldLength\n    miniSearch._averageFieldLength = averageFieldLength\n    miniSearch._fieldIds = fieldIds\n    miniSearch._storedFields = storedFields || {}\n    return miniSearch\n  }\n\n  /**\n  * @private\n  * @ignore\n  */\n  executeQuery (query, options = {}) {\n    options = { ...this._options.searchOptions, ...options }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: boosts[field] || 1 }), options.boost || {})\n\n    const {\n      boostDocument,\n      weights: { fuzzy: fuzzyWeight = 0.9, prefix: prefixWeight = 0.75 }\n    } = options\n\n    const exactMatch = termResults(this, query.term, boosts, boostDocument, this._index.get(query.term))\n\n    if (!query.fuzzy && !query.prefix) { return exactMatch }\n\n    const results = [exactMatch]\n\n    if (query.prefix) {\n      this._index.atPrefix(query.term).forEach((term, data) => {\n        const weightedDistance = (0.3 * (term.length - query.term.length)) / term.length\n        results.push(termResults(this, term, boosts, boostDocument, data, prefixWeight, weightedDistance))\n      })\n    }\n\n    if (query.fuzzy) {\n      const maxDistance = query.fuzzy < 1 ? Math.round(query.term.length * query.fuzzy) : query.fuzzy\n      Object.entries(this._index.fuzzyGet(query.term, maxDistance)).forEach(([term, [data, distance]]) => {\n        const weightedDistance = distance / term.length\n        results.push(termResults(this, term, boosts, boostDocument, data, fuzzyWeight, weightedDistance))\n      })\n    }\n\n    return results.reduce(combinators[OR], {})\n  }\n\n  /**\n  * @private\n  * @ignore\n  */\n  combineResults (results, combineWith = OR) {\n    if (results.length === 0) { return {} }\n    const operator = combineWith.toLowerCase()\n    return results.reduce(combinators[operator], null)\n  }\n\n  /**\n  * Allows serialization of the index to JSON, to possibly store it and later\n  * deserialize it with MiniSearch.loadJSON\n  *\n  * **Warning:** JSON (de)serialization of the index is currently tightly\n  * coupled to the index implementation. For this reason, the current\n  * implementation is to be considered a _beta_ feature, subject to breaking\n  * changes changes in future releases. If a breaking change is introduced,\n  * though, it will be reported in the changelog.\n  *\n  * @return {Object} the serializeable representation of the search index\n  */\n  toJSON () {\n    return {\n      index: this._index,\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: this._documentIds,\n      fieldIds: this._fieldIds,\n      fieldLength: this._fieldLength,\n      averageFieldLength: this._averageFieldLength,\n      storedFields: this._storedFields\n    }\n  }\n}\n\nMiniSearch.SearchableMap = SearchableMap\n\nconst addTerm = function (self, fieldId, documentId, term) {\n  self._index.update(term, indexData => {\n    indexData = indexData || {}\n    const fieldIndex = indexData[fieldId] || { df: 0, ds: {} }\n    if (fieldIndex.ds[documentId] == null) { fieldIndex.df += 1 }\n    fieldIndex.ds[documentId] = (fieldIndex.ds[documentId] || 0) + 1\n    return { ...indexData, [fieldId]: fieldIndex }\n  })\n}\n\nconst removeTerm = function (self, fieldId, documentId, term) {\n  if (!self._index.has(term)) {\n    warnDocumentChanged(self, documentId, fieldId, term)\n    return\n  }\n  self._index.update(term, indexData => {\n    const fieldIndex = indexData[fieldId]\n    if (fieldIndex == null || fieldIndex.ds[documentId] == null) {\n      warnDocumentChanged(self, documentId, fieldId, term)\n      return indexData\n    }\n    if (fieldIndex.ds[documentId] <= 1) {\n      if (fieldIndex.df <= 1) {\n        delete indexData[fieldId]\n        return indexData\n      }\n      fieldIndex.df -= 1\n    }\n    if (fieldIndex.ds[documentId] <= 1) {\n      delete fieldIndex.ds[documentId]\n      return indexData\n    }\n    fieldIndex.ds[documentId] -= 1\n    return { ...indexData, [fieldId]: fieldIndex }\n  })\n  if (Object.keys(self._index.get(term)).length === 0) {\n    self._index.delete(term)\n  }\n}\n\nconst warnDocumentChanged = function (self, shortDocumentId, fieldId, term) {\n  if (console == null || console.warn == null) { return }\n  const fieldName = Object.entries(self._fieldIds).find(([name, id]) => id === fieldId)[0]\n  console.warn(`MiniSearch: document with ID ${self._documentIds[shortDocumentId]} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`)\n}\n\nconst addDocumentId = function (self, documentId) {\n  const shortDocumentId = self._nextId.toString(36)\n  self._documentIds[shortDocumentId] = documentId\n  self._documentCount += 1\n  self._nextId += 1\n  return shortDocumentId\n}\n\nconst addFields = function (self, fields) {\n  fields.forEach((field, i) => { self._fieldIds[field] = i })\n}\n\nconst termResults = function (self, term, boosts, boostDocument, indexData, weight = 1, editDistance = 0) {\n  if (indexData == null) { return {} }\n  return Object.entries(boosts).reduce((results, [field, boost]) => {\n    const fieldId = self._fieldIds[field]\n    const { df, ds } = indexData[fieldId] || { ds: {} }\n    Object.entries(ds).forEach(([documentId, tf]) => {\n      const docBoost = boostDocument ? boostDocument(self._documentIds[documentId], term) : 1\n      if (!docBoost) { return }\n      const normalizedLength = self._fieldLength[documentId][fieldId] / self._averageFieldLength[fieldId]\n      results[documentId] = results[documentId] || { score: 0, match: {}, terms: [] }\n      results[documentId].terms.push(term)\n      results[documentId].match[term] = results[documentId].match[term] || []\n      results[documentId].score += docBoost * score(tf, df, self._documentCount, normalizedLength, boost, editDistance)\n      results[documentId].match[term].push(field)\n    })\n    return results\n  }, {})\n}\n\nconst addFieldLength = function (self, documentId, fieldId, count, length) {\n  self._averageFieldLength[fieldId] = self._averageFieldLength[fieldId] || 0\n  const totalLength = (self._averageFieldLength[fieldId] * count) + length\n  self._fieldLength[documentId] = self._fieldLength[documentId] || {}\n  self._fieldLength[documentId][fieldId] = length\n  self._averageFieldLength[fieldId] = totalLength / (count + 1)\n}\n\nconst saveStoredFields = function (self, documentId, doc) {\n  const { storeFields, extractField } = self._options\n  if (storeFields == null || storeFields.length === 0) { return }\n  self._storedFields[documentId] = self._storedFields[documentId] || {}\n\n  storeFields.forEach((fieldName) => {\n    const fieldValue = extractField(doc, fieldName)\n    if (fieldValue === undefined) { return }\n    self._storedFields[documentId][fieldName] = fieldValue\n  })\n}\n\nconst combinators = {\n  [OR]: function (a, b) {\n    return Object.entries(b).reduce((combined, [documentId, { score, match, terms }]) => {\n      if (combined[documentId] == null) {\n        combined[documentId] = { score, match, terms }\n      } else {\n        combined[documentId].score += score\n        combined[documentId].score *= 1.5\n        combined[documentId].terms = [...combined[documentId].terms, ...terms]\n        Object.assign(combined[documentId].match, match)\n      }\n      return combined\n    }, a || {})\n  },\n  [AND]: function (a, b) {\n    if (a == null) { return b }\n    return Object.entries(b).reduce((combined, [documentId, { score, match, terms }]) => {\n      if (a[documentId] === undefined) { return combined }\n      combined[documentId] = combined[documentId] || {}\n      combined[documentId].score = a[documentId].score + score\n      combined[documentId].match = { ...a[documentId].match, ...match }\n      combined[documentId].terms = [...a[documentId].terms, ...terms]\n      return combined\n    }, {})\n  }\n}\n\nconst tfIdf = function (tf, df, n) {\n  return tf * Math.log(n / df)\n}\n\nconst score = function (termFrequency, documentFrequency, documentCount, normalizedLength, boost, editDistance) {\n  const weight = boost / (1 + (0.333 * boost * editDistance))\n  return weight * tfIdf(termFrequency, documentFrequency, documentCount) / normalizedLength\n}\n\nconst termToQuery = (options) => (term, i, terms) => {\n  const fuzzy = (typeof options.fuzzy === 'function')\n    ? options.fuzzy(term, i, terms)\n    : options.fuzzy\n  const prefix = (typeof options.prefix === 'function')\n    ? options.prefix(term, i, terms)\n    : options.prefix\n  return { term, fuzzy, prefix }\n}\n\nconst uniq = function (array) {\n  return array.filter((element, i, array) => array.indexOf(element) === i)\n}\n\nconst isTruthy = (x) => !!x\n\nconst defaultOptions = {\n  idField: 'id',\n  extractField: (document, fieldName) => document[fieldName],\n  tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n  processTerm: (term, _fieldName) => term.toLowerCase(),\n  fields: undefined,\n  searchOptions: undefined,\n  storeFields: []\n}\n\nconst defaultSearchOptions = {\n  combineWith: OR,\n  prefix: false,\n  fuzzy: false,\n  weights: {}\n}\n\nconst defaultAutoSuggestOptions = {\n  prefix: (term, i, terms) => i === terms.length - 1\n}\n\n// This regular expression matches any Unicode space or punctuation character\n// Adapted from https://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7BZ%7D%5Cp%7BP%7D&abb=on&c=on&esc=on\nconst SPACE_OR_PUNCTUATION = /[\\n\\r -#%-*,-/:;?@[-\\]_{}\\u00A0\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u1680\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2000-\\u200A\\u2010-\\u2029\\u202F-\\u2043\\u2045-\\u2051\\u2053-\\u205F\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u3000-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]+/u\n\nexport default MiniSearch\n"],"names":["TreeIterator","set","type","node","_tree","keys","Object","path","length","next","value","this","dive","backtrack","done","last","LEAF","result","push","pop","key","_prefix","map","filter","join","VALUES","KEYS","Symbol","iterator","array","withinDistance","a","b","maxDistance","i","edit","stack","distance","ia","ib","results","NONE","ADD","DELETE","CHANGE","SearchableMap","tree","prefix","atPrefix","startsWith","Error","trackDown","slice","undefined","parentNode","nodeKey","find","k","clear","_size","delete","remove","entries","forEach","fn","fuzzyGet","maxEditDistance","query","innerStack","totDistance","d","Infinity","fuzzySearch","get","lookup","has","hasOwnProperty","createPath","update","values","_this","from","fromObject","object","toSplit","commonPrefix","Math","min","cleanup","merge","MiniSearch","options","_options","defaultOptions","searchOptions","defaultSearchOptions","fields","_index","_documentCount","_documentIds","_fieldIds","_fieldLength","_averageFieldLength","_nextId","_storedFields","addFields","add","document","extractField","tokenize","processTerm","idField","shortDocumentId","addDocumentId","saveStoredFields","field","tokens","addFieldLength","documentCount","term","processedTerm","isTruthy","addTerm","addAll","documents","_this2","addAllAsync","chunkSize","acc","chunk","promise","Promise","resolve","reduce","then","_this3","longId","removeTerm","_this4","removeAll","arguments","_this5","search","queryString","searchTokenize","searchProcessTerm","termToQuery","_this6","executeQuery","combinedResults","combineResults","combineWith","docId","score","match","terms","id","uniq","assign","sort","autoSuggest","defaultAutoSuggestOptions","suggestions","phrase","count","suggestion","loadJSON","json","loadJS","JSON","parse","getDefault","optionName","js","index","nextId","documentIds","fieldIds","fieldLength","averageFieldLength","storedFields","miniSearch","boosts","boost","boostDocument","weights","fuzzy","fuzzyWeight","prefixWeight","exactMatch","termResults","data","weightedDistance","_this7","round","combinators","operator","toLowerCase","toJSON","self","fieldId","documentId","indexData","fieldIndex","df","ds","warnDocumentChanged","console","warn","fieldName","toString","weight","editDistance","tf","docBoost","normalizedLength","totalLength","doc","storeFields","fieldValue","combined","termFrequency","documentFrequency","n","log","element","indexOf","x","string","_fieldName","split","SPACE_OR_PUNCTUATION"],"mappings":"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"}